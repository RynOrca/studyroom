<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>äº‘ç«¯è‡ªä¹ å®¤ - ä¸“æ³¨æ¯ä¸€åˆ»</title>
    <script src="/socket.io/socket.io.js"></script>
    <style>
        :root { --bg-color: #f0f2f5; --panel-bg: #ffffff; --primary-color: #52c41a; --primary-hover: #73d13d; --danger-color: #ff4d4f; --text-main: #262626; --text-secondary: #8c8c8c; --border-color: #f0f0f0; --radius: 12px; }
        * { box-sizing: border-box; margin: 0; padding: 0; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; }
        body { background-color: var(--bg-color); color: var(--text-main); height: 100vh; display: flex; flex-direction: column; overflow: hidden; }

        /* ====== å³ä¸Šè§’çŠ¶æ€æ  ====== */
        .top-bar { position: absolute; top: 20px; right: 20px; z-index: 20; display: flex; gap: 10px; }
        .stat-badge { background: rgba(0,0,0,0.6); color: white; padding: 6px 12px; border-radius: 20px; font-size: 13px; backdrop-filter: blur(4px); border: 1px solid rgba(255,255,255,0.2); display: flex; align-items: center; gap: 5px;}
        .host-badge { background: #faad14; color: white; padding: 2px 6px; border-radius: 4px; font-size: 10px; margin-left: 5px; font-weight: bold;}
        .edit-name-btn { cursor: pointer; transition: 0.2s; }
        .edit-name-btn:hover { color: var(--primary-color); }

        /* ====== è§†é¢‘åŒºåŸŸ (ä¸»å‰¯çª—å£æ— ç¼åˆ‡æ¢) ====== */
        .video-container { flex: 1; padding: 20px; display: flex; flex-direction: column; align-items: center; background: #1f1f1f; position: relative; overflow: hidden; }
        .video-grid { display: flex; gap: 20px; width: 100%; height: 100%; max-width: 1200px; align-items: flex-start; justify-content: center; }
        
        .video-box { background: #000; border-radius: var(--radius); overflow: hidden; position: relative; cursor: pointer; border: 2px solid transparent; transition: all 0.25s ease; display: flex; flex-direction: column;}
        .video-box video { width: 100%; height: 100%; object-fit: cover; display: block; flex: 1;}
        .video-label { position: absolute; bottom: 8px; left: 8px; background: rgba(0,0,0,0.7); color: white; padding: 4px 8px; border-radius: 4px; font-size: 12px; line-height: 1.4; display: flex; flex-direction: column; gap: 2px; max-width: 90%; word-wrap: break-word; z-index: 2;}

        /* ä¸»è§†é¢‘ï¼ˆæ”¾å¤§ï¼‰ */
        .video-box.large, .video-box.default-main { width: 800px; height: 600px; flex: 0 0 auto; }

        /* å³ä¾§ä¾§æ å®¹å™¨ */
        .video-sidebar { width: 220px; height: 600px; display: flex; flex-direction: column; gap: 10px; overflow-y: auto; align-self: flex-start; padding-right: 5px;}
        .video-sidebar .video-box { width: 200px; height: 200px; min-height: 200px; flex-shrink: 0; }
        .video-sidebar.empty { display: none; }
        .video-sidebar::-webkit-scrollbar { width: 6px; }
        .video-sidebar::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.3); border-radius: 3px; }

        .controls { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); display: flex; gap: 12px; background: rgba(255,255,255,0.1); padding: 10px 20px; border-radius: 50px; backdrop-filter: blur(10px); z-index: 11;}
        .controls button { padding: 10px 20px; border-radius: 50px; border: none; cursor: pointer; background: rgba(255,255,255,0.2); color: white; transition: 0.3s; }
        .controls button.active { background: var(--primary-color); }
        .controls button.btn-danger.active { background: var(--danger-color); }

        /* ====== åº•éƒ¨åŠŸèƒ½åŒº ====== */
        .bottom-panels { display: flex; height: 380px; border-top: 1px solid var(--border-color); background: var(--panel-bg); z-index: 5;}
        .panel { flex: 1; padding: 20px 25px; border-right: 1px solid var(--border-color); overflow-y: auto; display: flex; flex-direction: column; }
        .panel-header { display: flex; align-items: center; justify-content: space-between; margin-bottom: 15px; padding-bottom: 10px; border-bottom: 1px solid var(--border-color); }
        .panel h3 { font-size: 16px; font-weight: 600; display: flex; align-items: center; gap: 8px; }
        
        .input-group { display: flex; gap: 8px; margin-bottom: 15px; }
        input[type="text"], input[type="number"] { flex: 1; padding: 8px 12px; border: 1px solid #d9d9d9; border-radius: 6px; }
        button.styled-btn { padding: 8px 15px; border-radius: 6px; border: none; cursor: pointer; background: var(--primary-color); color: white; }
        button.styled-btn.secondary { background: #f5f5f5; color: var(--text-main); border: 1px solid #d9d9d9; }
        button.styled-btn.danger { background: #fff1f0; color: var(--danger-color); border: 1px solid #ffccc7; }
        button:disabled { opacity: 0.5; cursor: not-allowed !important; }

        /* ä»»åŠ¡åŒº */
        #listsContainer { flex: 1; overflow-y: auto; }
        .task-item { display: flex; align-items: center; justify-content: space-between; padding: 8px 0; border-bottom: 1px dashed var(--border-color); }
        .task-item.completed span { text-decoration: line-through; color: var(--text-secondary); }

        /* è®¡æ—¶åŒº */
        .timer-display { font-size: 56px; font-weight: 700; color: var(--primary-color); margin: 15px 0; text-align: center; font-variant-numeric: tabular-nums;}
        .timer-status-bar { width: 100%; text-align: center; padding: 6px; border-radius: 4px; background: #f5f5f5; margin-bottom: 15px; font-size: 13px; transition: 0.3s;}
        .timer-settings { background: #fafafa; border: 1px solid var(--border-color); border-radius: 8px; padding: 15px; display: flex; flex-direction: column; gap: 10px; }
        
        /* èŠå¤©å®¤åŒº */
        .chat-messages { flex: 1; overflow-y: auto; border: 1px solid var(--border-color); padding: 15px; margin-bottom: 12px; border-radius: 8px; background: #fafafa; display: flex; flex-direction: column; gap: 10px;}
        .message { font-size: 14px; padding: 8px 12px; border-radius: 8px; background: white; border: 1px solid var(--border-color); align-self: flex-start; max-width: 90%; word-wrap: break-word;}
        .message.self { align-self: flex-end; background: var(--primary-color); color: white; border-color: var(--primary-color); }
        .message .msg-meta { font-size: 12px; color: var(--text-secondary); margin-bottom: 4px;}
        .message.self .msg-meta { color: rgba(255,255,255,0.8); text-align: right;}
        .message img { max-width: 100%; border-radius: 8px; margin-top: 5px; max-height: 200px; object-fit: contain; cursor: pointer;}
        
        .user-list { font-size: 12px; margin-bottom: 10px; display: flex; gap: 5px; flex-wrap: wrap; }
        .user-tag { background: #e6f7ff; color: #1890ff; padding: 2px 8px; border-radius: 12px; border: 1px solid #91d5ff; cursor: pointer;}
    </style>
</head>
<body>

    <div class="top-bar">
        <div class="stat-badge edit-name-btn" onclick="editNickname()" title="ç‚¹å‡»ä¿®æ”¹æ˜µç§°">
            <span id="myNameDisplay">åŠ è½½ä¸­...</span> âœï¸
        </div>
        <div class="stat-badge" id="hostStatusBadge" style="display:none; background: #faad14;">ğŸ‘‘ ä¸»æŒäºº</div>
        <div class="stat-badge">ğŸ‘¥ åœ¨çº¿äººæ•°: <span id="userCountDisplay">1</span></div>
    </div>

    <div class="video-container">
        <div class="video-grid" id="videoGrid">
            <div class="video-box" id="localVideoBox" onclick="togglePin('localVideoBox')">
                <video id="localVideo" autoplay muted playsinline></video>
                <div class="video-label"><span>æˆ‘ (æœªå¼€å¯)</span></div>
            </div>
        </div>
        
        <div class="controls">
            <button id="btnMic" onclick="toggleMic()">ğŸ¤ å¼€å¯éº¦å…‹é£</button>
            <button id="btnCam" onclick="toggleCam()">ğŸ“· å¼€å¯æ‘„åƒå¤´</button>
            <button id="btnScreen" onclick="toggleScreenShare()" class="btn-danger">ğŸ’» å…±äº«å±å¹•</button>
        </div>
    </div>

    <div class="bottom-panels">
        <div class="panel" id="taskPanel">
            <div class="panel-header"><h3>ğŸ“‹ ä»»åŠ¡æ¸…å•</h3></div>
            <div class="input-group">
                <input type="text" id="newListInput" placeholder="è¾“å…¥æ¸…å•åç§°...">
                <button class="styled-btn" onclick="createList()">æ–°å»º</button>
            </div>
            <div id="listsContainer"></div>
        </div>

        <div class="panel" id="timerPanel">
            <div class="panel-header"><h3>â±ï¸ ä¸“æ³¨è®¡æ—¶</h3></div>
            <div class="timer-display" id="timeDisplay">25:00</div>
            <div class="timer-status-bar" id="timerStatus">å‡†å¤‡å°±ç»ª</div>
            
            <div class="timer-settings">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                    <span style="font-size: 14px;">ä¸“æ³¨(åˆ†): <input type="number" id="focusTime" value="25" style="width:120px; text-align:center;"></span>
                    <span style="font-size: 14px;">ä¼‘æ¯(åˆ†): <input type="number" id="breakTime" value="5" style="width:120px; text-align:center;"></span>
                </div>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
                    <button class="styled-btn" onclick="startPomodoro()">ç•ªèŒ„é’Ÿ</button>
                    <button class="styled-btn secondary" onclick="startStopwatch()">æ­£è®¡æ—¶</button>
                    <button class="styled-btn" id="btnPause" onclick="togglePauseTimer()" style="display:none; background:#faad14;">æš‚åœ</button>
                    <button class="styled-btn danger" onclick="stopTimer()">åœæ­¢</button>
                </div>
            </div>
        </div>

        <div class="panel" id="reflectionPanel">
            <div class="panel-header">
                <h3>ğŸ’¬ èŠå¤©å®¤</h3>
                <button id="hostChatToggleBtn" class="styled-btn danger" style="display:none; padding: 4px 8px; font-size: 12px;" onclick="toggleRoomChat()">ç¦è¨€å…¨å‘˜</button>
            </div>
            <div class="user-list" id="userListContainer"></div>
            <div class="chat-messages" id="chatBox"></div>
            
            <div class="input-group">
                <input type="file" id="imageInput" accept="image/png, image/jpeg, image/gif" style="display: none;" onchange="handleImageUpload(event)">
                <button class="styled-btn secondary" onclick="document.getElementById('imageInput').click()" title="å‘é€å›¾ç‰‡/GIF">ğŸ–¼ï¸</button>
                <input type="text" id="reflectionInput" placeholder="å‘é€æ¶ˆæ¯...">
                <button class="styled-btn" id="btnSendChat" onclick="sendReflection()">å‘é€</button>
            </div>
        </div>
    </div>

    <script>
        const ROOM_ID = 'default_study_room';
        let socket;
        let myUserId;
        let isHost = false;
        let roomUsers = [];
        let roomDataFromServer = { names: {}, timers: {} };

        let myNickname = localStorage.getItem('study_nickname') || 'åŒå­¦';

        // å¸ƒå±€çŠ¶æ€
        let currentMainId = 'localVideoBox';
        let isLargeMode = false;

        // å…¨å±€ä»»åŠ¡è®°å½•ï¼ˆé’ˆå¯¹â€œå¹²å®ƒï¼â€æŒ‰é’®ï¼‰
        let currentFocusTask = ''; 

        // WebRTC çŠ¶æ€
        let peerConnections = {}; 
        let localStream = null;
        let cameraTrack = null; 
        let screenAudioTrack = null; // ç‹¬ç«‹å­˜å‚¨ç³»ç»ŸéŸ³é¢‘è½¨ï¼Œé˜²æ­¢å’Œéº¦å…‹é£å†²çª
        let isCamOpen = false;
        let isMicOpen = false;
        let isSharingScreen = false; 

        window.onload = () => { 
            initSocket(); 
            createList('ä»Šæ—¥ç›®æ ‡'); 
            arrangeLayout(currentMainId, isLargeMode); 
        };

        function initSocket() {
            socket = io();

            socket.on('connect', () => {
                myUserId = socket.id;
                document.getElementById('myNameDisplay').innerText = myNickname;
                socket.emit('join_room', ROOM_ID);
                socket.emit('update_name', myNickname); 
            });

            socket.on('room_update', (data) => {
                roomDataFromServer = data; 
                roomUsers = data.users;
                document.getElementById('userCountDisplay').innerText = roomUsers.length;
                
                isHost = (data.host === myUserId);
                document.getElementById('hostStatusBadge').style.display = isHost ? 'flex' : 'none';
                document.getElementById('hostChatToggleBtn').style.display = isHost ? 'block' : 'none';
                
                renderUserList(data.host);
                updateAllVideoLabels();

                // ç¦è¨€é€»è¾‘å¤„ç†
                const chatInput = document.getElementById('reflectionInput');
                const chatBtn = document.getElementById('btnSendChat');
                const imgBtn = document.querySelector('button[onclick="document.getElementById(\'imageInput\').click()"]');
                const toggleBtn = document.getElementById('hostChatToggleBtn');
                
                if (!data.chatEnabled && !isHost) {
                    chatInput.disabled = true; chatBtn.disabled = true; imgBtn.disabled = true;
                    chatInput.placeholder = "ä¸»æŒäººå·²å…³é—­èŠå¤©å®¤";
                } else {
                    chatInput.disabled = false; chatBtn.disabled = false; imgBtn.disabled = false;
                    chatInput.placeholder = "å‘é€æ¶ˆæ¯...";
                }
                
                if (isHost) {
                    toggleBtn.innerText = data.chatEnabled ? "ç¦è¨€å…¨å‘˜" : "è§£é™¤ç¦è¨€";
                    toggleBtn.className = data.chatEnabled ? "styled-btn danger" : "styled-btn";
                }
            });

            socket.on('chat_message', (msgData) => {
                appendMessage(msgData.userName, msgData.message, msgData.time, false, msgData.isImage);
            });

            // WebRTC ä¿¡ä»¤
            socket.on('user_joined', async (newUserId) => {
                const pc = createPeerConnection(newUserId);
                if (localStream) localStream.getTracks().forEach(track => pc.addTrack(track, localStream));
                const offer = await pc.createOffer();
                await pc.setLocalDescription(offer);
                socket.emit('offer', { target: newUserId, caller: myUserId, sdp: offer });
            });
            
            socket.on('offer', async (data) => {
                const pc = createPeerConnection(data.caller);
                await pc.setRemoteDescription(new RTCSessionDescription(data.sdp));
                if (localStream) localStream.getTracks().forEach(track => pc.addTrack(track, localStream));
                const answer = await pc.createAnswer();
                await pc.setLocalDescription(answer);
                socket.emit('answer', { target: data.caller, serval: myUserId, sdp: answer });
            });
            
            socket.on('answer', async (data) => {
                const pc = peerConnections[data.serval];
                if (pc) await pc.setRemoteDescription(new RTCSessionDescription(data.sdp));
            });
            
            socket.on('ice-candidate', async (data) => {
                const pc = peerConnections[data.from];
                if (pc) await pc.addIceCandidate(new RTCIceCandidate(data.candidate));
            });
            
            socket.on('user_left', (userId) => { closePeerConnection(userId); });
        }

        // ================= æƒé™ä¸ç”¨æˆ·ä¿¡æ¯ =================
        function editNickname() {
            const newName = prompt("è¯·è¾“å…¥æ–°æ˜µç§° (2-10ä¸ªå­—ç¬¦)ï¼š", myNickname);
            if (newName && newName.trim().length >= 2 && newName.trim().length <= 10) {
                myNickname = newName.trim();
                localStorage.setItem('study_nickname', myNickname);
                document.getElementById('myNameDisplay').innerText = myNickname;
                socket.emit('update_name', myNickname);
            } else if (newName !== null) {
                alert("æ˜µç§°é•¿åº¦éœ€åœ¨ 2 åˆ° 10 ä¸ªå­—ç¬¦ä¹‹é—´ï¼");
            }
        }

        function renderUserList(hostId) {
            const container = document.getElementById('userListContainer');
            container.innerHTML = '';
            roomUsers.forEach(id => {
                const isMe = (id === myUserId);
                const isThisUserHost = (id === hostId);
                const customName = isMe ? myNickname : (roomDataFromServer.names[id] || `æˆå‘˜(${id.substring(0,4)})`); 
                
                const tag = document.createElement('span');
                tag.className = 'user-tag';
                tag.innerHTML = `${customName} ${isThisUserHost ? '<span class="host-badge">ä¸»æŒ</span>' : ''}`;
                
                if (isHost && !isMe) {
                    tag.title = "ç‚¹å‡»ç§»äº¤ä¸»æŒäºº";
                    tag.onclick = () => { if(confirm(`ç§»äº¤ä¸»æŒäººç»™ ${customName}ï¼Ÿ`)) socket.emit('transfer_host', id); };
                }
                container.appendChild(tag);
            });
        }

        function toggleRoomChat() {
            const btn = document.getElementById('hostChatToggleBtn');
            const isCurrentlyEnabled = btn.innerText === "ç¦è¨€å…¨å‘˜";
            socket.emit('toggle_chat', !isCurrentlyEnabled);
        }

        function updateAllVideoLabels() {
            roomUsers.forEach(id => {
                const isMe = (id === myUserId);
                const customName = isMe ? myNickname : (roomDataFromServer.names[id] || `æˆå‘˜(${id.substring(0,4)})`);
                const timerStatus = roomDataFromServer.timers[id] || 'æš‚æ— ä¸“æ³¨ä»»åŠ¡';
                const videoLabelStr = `<b>${customName}</b><span style="font-size:11px; color:#ddd;">${timerStatus}</span>`;

                if (isMe) {
                    const label = document.querySelector('#localVideoBox .video-label');
                    if (label) label.innerHTML = videoLabelStr;
                } else {
                    const label = document.querySelector(`#box_${id} .video-label`);
                    if (label) label.innerHTML = videoLabelStr;
                }
            });
        }

        // ================= WebRTC æ ¸å¿ƒä¸ä¿®å¤ =================
        function createPeerConnection(remoteUserId) {
            if (peerConnections[remoteUserId]) return peerConnections[remoteUserId];
            const pc = new RTCPeerConnection({ iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] });
            peerConnections[remoteUserId] = pc;
            
            pc.onicecandidate = (event) => {
                if (event.candidate) socket.emit('ice-candidate', { target: remoteUserId, from: myUserId, candidate: event.candidate });
            };

            // ä¿®å¤ï¼šåŠ¨æ€æ·»åŠ éº¦å…‹é£æˆ–å±å¹•éŸ³é¢‘æ—¶ï¼Œè§¦å‘é‡æ–°åå•†
            pc.onnegotiationneeded = async () => {
                try {
                    console.log('[WebRTC æ—¥å¿—] è§¦å‘é‡æ–°åå•†');
                    const offer = await pc.createOffer();
                    await pc.setLocalDescription(offer);
                    socket.emit('offer', { target: remoteUserId, caller: myUserId, sdp: pc.localDescription });
                } catch (e) { console.error('åå•†å¤±è´¥', e); }
            };

            // æ ¸å¿ƒä¿®å¤ï¼šåˆ†ç¦»éŸ³é¢‘å’Œè§†é¢‘æ’­æ”¾ï¼Œå®Œç¾æ”¯æŒå¤šéŸ³é¢‘è½¨ (éº¦å…‹é£+ç³»ç»ŸéŸ³)
            pc.ontrack = (event) => {
                console.log(`[WebRTC æ—¥å¿—] æ”¶åˆ°è½¨é“: ${event.track.kind}`);
                
                // å•ç‹¬å¤„ç†éŸ³é¢‘è½¨é“ï¼Œåˆ›å»ºç‹¬ç«‹çš„ <audio> æ ‡ç­¾æ’­æ”¾
                if (event.track.kind === 'audio') {
                    let audioEl = document.getElementById(`audio_${event.track.id}`);
                    if (!audioEl) {
                        audioEl = document.createElement('audio');
                        audioEl.id = `audio_${event.track.id}`;
                        audioEl.autoplay = true;
                        audioEl.srcObject = new MediaStream([event.track]);
                        document.body.appendChild(audioEl);
                        
                        event.track.onended = () => { if (audioEl) audioEl.remove(); };
                    }
                }

                // å¤„ç†è§†é¢‘è½¨é“
                let remoteVideoE = document.getElementById(`video_${remoteUserId}`);
                if (!remoteVideoE) {
                    // å¯¹æ–¹çš„è§†é¢‘æ ‡ç­¾é™éŸ³ï¼Œé¿å…å’Œä¸Šé¢çš„ç‹¬ç«‹ audio æ ‡ç­¾å£°éŸ³é‡å¤
                    const html = `<div class="video-box" id="box_${remoteUserId}" onclick="togglePin('box_${remoteUserId}')">
                        <video id="video_${remoteUserId}" autoplay playsinline muted></video>
                        <div class="video-label"><span>åŠ è½½ä¸­...</span></div>
                    </div>`;
                    document.getElementById('videoGrid').insertAdjacentHTML('beforeend', html);
                    remoteVideoE = document.getElementById(`video_${remoteUserId}`);
                }

                // æŒ‚è½½æ–°çš„åª’ä½“æµ
                if (remoteVideoE.srcObject !== event.streams[0]) {
                    remoteVideoE.srcObject = event.streams[0];
                }
                
                const boxEl = document.getElementById(`box_${remoteUserId}`);
                if (boxEl) { boxEl.style.width = ''; boxEl.style.height = ''; boxEl.style.display = 'block'; }
                
                updateAllVideoLabels();
                setTimeout(() => arrangeLayout(currentMainId, isLargeMode), 50);
            };
            return pc;
        }

        function closePeerConnection(userId) {
            if (peerConnections[userId]) { peerConnections[userId].close(); delete peerConnections[userId]; }
            const box = document.getElementById(`box_${userId}`);
            if (box) box.remove();
            setTimeout(() => arrangeLayout(currentMainId, isLargeMode), 50);
        }

        function replaceTrackInPeers(newTrack) {
            console.log(`[WebRTC æ—¥å¿—] å‡†å¤‡åŒæ­¥è½¨é“: ${newTrack.kind}`);
            Object.values(peerConnections).forEach(pc => {
                const sender = pc.getSenders().find(s => {
                    if (!s.track) return false;
                    // é˜²æ­¢éº¦å…‹é£è½¨é“è¦†ç›–å±å¹•å…±äº«çš„ç³»ç»ŸéŸ³é¢‘è½¨é“
                    if (newTrack.kind === 'audio') {
                        return s.track.kind === 'audio' && s.track !== screenAudioTrack;
                    }
                    return s.track.kind === newTrack.kind;
                });

                if (sender) {
                    sender.replaceTrack(newTrack); 
                } else if (localStream) {
                    pc.addTrack(newTrack, localStream); // è§¦å‘ onnegotiationneeded
                }
            });
        }

        // ================= åª’ä½“è®¾å¤‡æ§åˆ¶ =================
        async function toggleCam() {
            const btn = document.getElementById('btnCam');
            if (isSharingScreen && !isCamOpen) return alert("è¯·å…ˆåœæ­¢å±å¹•å…±äº«ã€‚");

            if (!isCamOpen) {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ video: true });
                    cameraTrack = stream.getVideoTracks()[0];
                    if (!localStream) localStream = new MediaStream([cameraTrack]);
                    else localStream.addTrack(cameraTrack);
                    
                    document.getElementById('localVideo').srcObject = localStream;
                    replaceTrackInPeers(cameraTrack); 
                    
                    isCamOpen = true;
                    btn.innerText = "ğŸ“· å…³é—­æ‘„åƒå¤´"; btn.classList.add('active');
                } catch (err) { alert("æ— æ³•è®¿é—®æ‘„åƒå¤´: " + err.message); }
            } else {
                try {
                    if (cameraTrack) {
                        cameraTrack.enabled = false; cameraTrack.stop();
                        if (localStream) localStream.removeTrack(cameraTrack);
                    }
                } catch(e) {}
                isCamOpen = false;
                btn.innerText = "ğŸ“· å¼€å¯æ‘„åƒå¤´"; btn.classList.remove('active');
                
                const lv = document.getElementById('localVideo');
                if (!localStream || localStream.getVideoTracks().length === 0) {
                    if (lv) lv.srcObject = null;
                }
            }
        }

        async function toggleMic() {
            const btn = document.getElementById('btnMic');
            
            if (!localStream || !localStream.getAudioTracks().find(t => t !== screenAudioTrack)) {
                try { 
                    const audioStream = await navigator.mediaDevices.getUserMedia({ audio: true }); 
                    const audioTrack = audioStream.getAudioTracks()[0];
                    if (!localStream) localStream = new MediaStream();
                    localStream.addTrack(audioTrack);
                    audioTrack.enabled = false; // åˆå§‹é™éŸ³
                } catch(e) { 
                    return alert("æ— æ³•è·å–éº¦å…‹é£æƒé™ï¼Œè¯·æ£€æŸ¥æµè§ˆå™¨è®¾ç½®æˆ–è®¾å¤‡è¿æ¥ï¼");
                }
            }
            
            // æ‰¾åˆ°å±äºéº¦å…‹é£çš„éŸ³é¢‘è½¨
            const audioTrack = localStream.getAudioTracks().find(t => t !== screenAudioTrack);
            
            if (!isMicOpen) {
                audioTrack.enabled = true;
                console.log('[çŠ¶æ€] éº¦å…‹é£å·²å¼€å¯');
                replaceTrackInPeers(audioTrack); 
                isMicOpen = true;
                btn.innerText = "ğŸ¤ å…³é—­éº¦å…‹é£"; btn.classList.add('active');
            } else {
                audioTrack.enabled = false;
                console.log('[çŠ¶æ€] éº¦å…‹é£å·²å…³é—­');
                isMicOpen = false;
                btn.innerText = "ğŸ¤ å¼€å¯éº¦å…‹é£"; btn.classList.remove('active');
            }
        }

        async function toggleScreenShare() {
            const btn = document.getElementById('btnScreen');
            if (isCamOpen && !isSharingScreen) await toggleCam(); 

            if (!isSharingScreen) {
                try {
                    // è¯·æ±‚å±å¹•è§†é¢‘å’Œç³»ç»ŸéŸ³é¢‘
                    const stream = await navigator.mediaDevices.getDisplayMedia({ video: true, audio: true });
                    const screenTrack = stream.getVideoTracks()[0];
                    screenAudioTrack = stream.getAudioTracks()[0]; // å¯èƒ½ä¸ºç©ºï¼ˆå¦‚æœç”¨æˆ·æœªå‹¾é€‰åˆ†äº«éŸ³é¢‘ï¼‰

                    if (!localStream) localStream = new MediaStream([screenTrack]);
                    document.getElementById('localVideo').srcObject = new MediaStream([screenTrack]);
                    
                    // åŒæ­¥è§†é¢‘è½¨é“
                    replaceTrackInPeers(screenTrack); 

                    // ç‹¬ç«‹è¿½åŠ ç³»ç»ŸéŸ³é¢‘è½¨é“
                    if (screenAudioTrack) {
                        console.log(`[çŠ¶æ€] æ•è·åˆ°ç³»ç»ŸéŸ³é¢‘`);
                        Object.values(peerConnections).forEach(pc => {
                            pc.addTrack(screenAudioTrack, localStream); 
                        });
                        screenAudioTrack.onended = () => { if (isSharingScreen) toggleScreenShare(); };
                    }

                    isSharingScreen = true;
                    btn.innerText = "ğŸ’» åœæ­¢å…±äº«"; btn.classList.add('active');
                    screenTrack.onended = () => { if(isSharingScreen) toggleScreenShare(); };
                } catch (err) { console.log("å–æ¶ˆå…±äº«"); }
            } else {
                try {
                    const src = document.getElementById('localVideo').srcObject;
                    if (src && src.getVideoTracks().length) src.getVideoTracks()[0].stop();
                    
                    // é”€æ¯å¹¶æ–­å¼€ç³»ç»ŸéŸ³é¢‘
                    if (screenAudioTrack) {
                        screenAudioTrack.stop();
                        Object.values(peerConnections).forEach(pc => {
                            const sender = pc.getSenders().find(s => s.track === screenAudioTrack);
                            if (sender) pc.removeTrack(sender); 
                        });
                        screenAudioTrack = null;
                    }
                } catch(e) {}
                isSharingScreen = false;
                btn.innerText = "ğŸ’» å…±äº«å±å¹•"; btn.classList.remove('active');
                document.getElementById('localVideo').srcObject = null;
            }
        }

        // ================= è§†é¢‘å¸ƒå±€ä¸æ— ç¼åˆ‡æ¢ =================
        function togglePin(boxId) {
            if (currentMainId === boxId && isLargeMode) {
                isLargeMode = false; currentMainId = 'localVideoBox';
            } else {
                currentMainId = boxId; isLargeMode = true;
            }
            arrangeLayout(currentMainId, isLargeMode);
        }

        function arrangeLayout(mainId, large) {
            const grid = document.getElementById('videoGrid');
            const existingBoxes = Array.from(document.querySelectorAll('.video-box'));
            let mainBox = existingBoxes.find(b => b.id === mainId) || existingBoxes.find(b => b.id === 'localVideoBox') || existingBoxes[0] || null;

            grid.innerHTML = '';
            if (!mainBox) return;

            existingBoxes.forEach(b => { 
                b.style.width = ''; b.style.height = ''; b.style.display = 'block'; 
                b.classList.remove('large', 'default-main'); 
            });

            if (large) mainBox.classList.add('large'); 
            else mainBox.classList.add('default-main');

            grid.appendChild(mainBox);

            const sidebar = document.createElement('div');
            sidebar.className = 'video-sidebar';
            const others = existingBoxes.filter(b => b.id !== mainBox.id);

            if (others.length === 0) sidebar.classList.add('empty');
            
            others.forEach(b => { sidebar.appendChild(b); });
            grid.appendChild(sidebar);

            // ä¿®å¤ï¼šDOM ç§»åŠ¨åæ¢å¤è§†é¢‘æ’­æ”¾
            setTimeout(() => {
                document.querySelectorAll('.video-box video').forEach(videoEl => {
                    if (videoEl.paused && videoEl.srcObject) {
                        videoEl.play().catch(e => console.log('è‡ªåŠ¨æ’­æ”¾æ¢å¤å¤±è´¥', e));
                    }
                });
            }, 100);
        }

        // ================= ç•ªèŒ„é’Ÿé€»è¾‘ä¸ä»»åŠ¡åŒæ­¥ =================
        let timerInterval;
        let totalSeconds = 0; 
        let isTimerRunning = false;
        let isTimerPaused = false; 

        // åŒºåˆ†å‰©ä½™æ—¶é•¿å’Œå·²è®¡æ—¶é•¿å¹¿æ’­
        function broadcastTimerStatus(isPomodoro) {
            if (!socket) return;
            
            if (!isTimerRunning && !isTimerPaused) {
                const idleText = currentFocusTask ? `å¾…ä¸“æ³¨ï¼š${currentFocusTask}` : 'æš‚æ— ä¸“æ³¨ä»»åŠ¡';
                socket.emit('sync_timer', idleText);
                return;
            }
            
            const taskName = currentFocusTask || (isPomodoro ? "ç•ªèŒ„é’Ÿ" : "æ­£è®¡æ—¶");
            const m = Math.floor(totalSeconds / 60);
            const s = totalSeconds % 60;
            
            // ç•ªèŒ„é’Ÿ=å‰©ä½™æ—¶é•¿ï¼Œæ­£è®¡æ—¶=å·²è®¡æ—¶é•¿
            const timeStr = isPomodoro ? `å‰©ä½™${m}åˆ†${s}ç§’` : `å·²è®¡æ—¶${m}åˆ†${s}ç§’`;
            const stateStr = isTimerPaused ? " (æš‚åœ)" : "";
            
            socket.emit('sync_timer', `ä»»åŠ¡ï¼š${taskName} | ${timeStr}${stateStr}`);
        }

        function updateDisplay(sec) {
            document.getElementById('timeDisplay').innerText = 
                `${Math.floor(sec / 60).toString().padStart(2, '0')}:${(sec % 60).toString().padStart(2, '0')}`;
            
            // æ¯ 10 ç§’å¹¿æ’­ä¸€æ¬¡æœ€æ–°æ—¶é—´è¿›åº¦ï¼Œå‡å°‘é¢‘ç¹é€šä¿¡ï¼ŒåŒæ—¶ä¿è¯è¾ƒé«˜ç²¾åº¦
            if (sec % 10 === 0) broadcastTimerStatus(document.getElementById('timerStatus').innerText.includes('ğŸ”¥'));
        }

        // ç‚¹å‡»â€œå¹²å®ƒï¼â€è®¾ç½®å½“å‰ä¸“æ³¨ä»»åŠ¡
        function setFocusTask(taskName) {
            currentFocusTask = taskName;
            const statusEl = document.getElementById('timerStatus');
            
            if (isTimerRunning || isTimerPaused) {
                const isPomodoro = statusEl.innerText.includes('ğŸ”¥') || statusEl.innerText.includes('æš‚åœ');
                alert(`å·²å°†å½“å‰ä¸“æ³¨ä»»åŠ¡æ— ç¼åˆ‡æ¢ä¸ºï¼š${taskName}`);
                broadcastTimerStatus(isPomodoro);
            } else {
                statusEl.innerText = `ğŸ¯ å¾…ä¸“æ³¨ï¼š${taskName}`;
                statusEl.style.background = "#e6f7ff";
                statusEl.style.color = "#1890ff";
                broadcastTimerStatus(false); 
            }
        }

        function startStopwatch() {
            clearInterval(timerInterval);
            totalSeconds = 0; isTimerRunning = true; isTimerPaused = false;
            document.getElementById('timerStatus').innerText = "æ­£è®¡æ—¶ä¸­...";
            document.getElementById('timerStatus').style.background = "#e6f7ff";
            document.getElementById('timerStatus').style.color = "#1890ff";
            document.getElementById('btnPause').style.display = 'inline-block';
            document.getElementById('btnPause').innerText = 'æš‚åœ';
            
            broadcastTimerStatus(false);
            timerInterval = setInterval(() => {
                if (!isTimerPaused) { totalSeconds++; updateDisplay(totalSeconds); }
            }, 1000);
        }

        function startPomodoro() {
            clearInterval(timerInterval);
            const mins = parseInt(document.getElementById('focusTime').value) || 25;
            totalSeconds = mins * 60; isTimerRunning = true; isTimerPaused = false;
            
            document.getElementById('timerStatus').innerText = "ğŸ”¥ ä¸“æ³¨ä¸­...";
            document.getElementById('timerStatus').style.background = "#fff1f0";
            document.getElementById('timerStatus').style.color = "#cf1322";
            document.getElementById('btnPause').style.display = 'inline-block';
            document.getElementById('btnPause').innerText = 'æš‚åœ';
            updateDisplay(totalSeconds);
            broadcastTimerStatus(true);
            
            timerInterval = setInterval(() => {
                if (!isTimerPaused) {
                    if (totalSeconds > 0) {
                        totalSeconds--; updateDisplay(totalSeconds);
                    } else {
                        clearInterval(timerInterval); alert("ä¸“æ³¨ç»“æŸï¼å¼€å§‹ä¼‘æ¯å§ã€‚");
                    }
                }
            }, 1000);
        }

        function togglePauseTimer() {
            if (!isTimerRunning) return;
            isTimerPaused = !isTimerPaused;
            const btn = document.getElementById('btnPause');
            const status = document.getElementById('timerStatus');
            const isPomodoro = status.innerText.includes('ğŸ”¥') || status.innerText.includes('æš‚åœ');
            
            if (isTimerPaused) {
                btn.innerText = "ç»§ç»­"; btn.style.background = '#52c41a';
                status.innerText = "â¸ï¸ è®¡æ—¶å·²æš‚åœ";
                status.style.background = "#fffbe6"; status.style.color = "#d48806";
            } else {
                btn.innerText = "æš‚åœ"; btn.style.background = "#faad14";
                if (isPomodoro) {
                    status.innerText = "ğŸ”¥ ä¸“æ³¨ä¸­...";
                    status.style.background = "#fff1f0"; status.style.color = "#cf1322";
                } else {
                    status.innerText = "æ­£è®¡æ—¶ä¸­...";
                    status.style.background = "#e6f7ff"; status.style.color = "#1890ff";
                }
            }
            broadcastTimerStatus(isPomodoro); 
        }

        function stopTimer() {
            clearInterval(timerInterval);
            isTimerRunning = false; isTimerPaused = false;
            document.getElementById('timerStatus').innerText = "å·²åœæ­¢";
            document.getElementById('timerStatus').style.background = "#f5f5f5";
            document.getElementById('timerStatus').style.color = "var(--text-secondary)";
            document.getElementById('btnPause').style.display = 'none';
            broadcastTimerStatus(false);
        }

        // ================= èŠå¤©å®¤ä¸ä»»åŠ¡ =================
        function createList(name) {
            const listId = `list_${Date.now()}`;
            const html = `<div style="margin-bottom:10px; border:1px solid #eee; padding:10px; border-radius:8px;">
                <div style="font-weight:bold; margin-bottom:8px;">ğŸ“‚ ${name || 'æ–°æ¸…å•'}</div>
                <div style="display:flex; gap:5px;"><input type="text" id="taskInput_${listId}"><button class="styled-btn" onclick="addTask('${listId}')">æ·»åŠ </button></div>
                <div id="tasks_${listId}" style="margin-top:10px;"></div></div>`;
            document.getElementById('listsContainer').insertAdjacentHTML('beforeend', html);
        }
        
        function addTask(listId) {
            const val = document.getElementById(`taskInput_${listId}`).value;
            if(!val) return;
            const taskId = `task_${Date.now()}`;
            const html = `
                <div class="task-item" id="${taskId}">
                    <label style="flex:1; display:flex; align-items:center; gap:8px; cursor:pointer;">
                        <input type="checkbox" onclick="document.getElementById('${taskId}').classList.toggle('completed')"> 
                        <span>${val}</span>
                    </label>
                    <button class="styled-btn" style="padding: 4px 10px; font-size: 12px; border-radius: 4px; margin-left: 10px;" 
                            onclick="setFocusTask('${val}')">å¹²å®ƒï¼</button>
                </div>`;
            document.getElementById(`tasks_${listId}`).insertAdjacentHTML('beforeend', html);
            document.getElementById(`taskInput_${listId}`).value = '';
        }

        // å›¾ç‰‡/GIF ä¸Šä¼ è½¬æ¢
        function handleImageUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
            if (file.size > 5 * 1024 * 1024) { 
                alert('å›¾ç‰‡/GIF å¤§å°ä¸èƒ½è¶…è¿‡ 5MBï¼');
                event.target.value = ''; return;
            }
            const reader = new FileReader();
            reader.onload = (e) => {
                const base64Data = e.target.result;
                const timeStr = new Date().toLocaleTimeString();
                appendMessage(myNickname, base64Data, timeStr, true, true);
                if(socket) socket.emit('chat_message', { userName: isHost ? `ğŸ‘‘ä¸»æŒäºº(${myNickname})` : myNickname, message: base64Data, time: timeStr, isImage: true });
            };
            reader.readAsDataURL(file);
            event.target.value = ''; 
        }

        function sendReflection() {
            const input = document.getElementById('reflectionInput');
            const msg = input.value.trim();
            if (!msg) return;
            const timeStr = new Date().toLocaleTimeString();
            appendMessage(myNickname, msg, timeStr, true, false);
            if(socket) socket.emit('chat_message', { userName: isHost ? `ğŸ‘‘ä¸»æŒäºº(${myNickname})` : myNickname, message: msg, time: timeStr, isImage: false });
            input.value = '';
        }

        function appendMessage(user, msg, time, isSelf, isImage = false) {
            const box = document.getElementById('chatBox');
            // ç‚¹å‡»å›¾ç‰‡å¯å…¨å±æŸ¥çœ‹
            const contentHtml = isImage ? `<img src="${msg}" onclick="window.open(this.src)">` : `<div>${msg}</div>`;
            box.insertAdjacentHTML('beforeend', `<div class="message ${isSelf ? 'self' : ''}"><div class="msg-meta">${user} ${time}</div>${contentHtml}</div>`);
            box.scrollTop = box.scrollHeight;
        }
        
        const _refInput = document.getElementById('reflectionInput');
        if (_refInput) _refInput.addEventListener('keypress', (e) => { if(e.key === 'Enter') sendReflection(); });
    </script>
</body>
</html>
<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>äº‘ç«¯è‡ªä¹ å®¤ - ä¸“æ³¨æ¯ä¸€åˆ»</title>
    <script src="/socket.io/socket.io.js"></script>
    <script>
      // æå‰åŠ è½½ä¸»é¢˜ï¼Œé˜²æ­¢é¡µé¢é—ªçƒ
      (function initTheme() {
          const savedTheme = localStorage.getItem('study_theme');
          if (savedTheme === 'minimal') {
              document.documentElement.setAttribute('data-theme', 'minimal');
          }
      })();
    </script>
    <style>
      /* ================= 1. é»˜è®¤ä¸»é¢˜ï¼šæ¸å˜æ¯›ç»ç’ƒ (Glassmorphism) ================= */
      :root {
        --radius-sm: 8px;
        --radius-md: 16px;
        --radius-lg: 24px;
        --transition-fast: 0.2s ease;

        --primary-color: #667eea;
        --primary-light: #764ba2;
        --primary-hover: #5a6fe0;
        --danger-color: #fc6076;
        --danger-hover: #ff9a44;
        --warning-color: #f6d365;
        --success-color: #1dd1a1;
        --text-main: #2d3748;
        --text-secondary: #4a5568;
        --text-tertiary: #a0aec0;
        
        /* åŸºç¡€ç»“æ„å˜é‡ */
        --body-bg: linear-gradient(135deg, #e0c3fc 0%, #8ec5fc 100%);
        --card-bg: rgba(255, 255, 255, 0.65);
        --card-backdrop: blur(12px);
        --card-border: 1px solid rgba(255, 255, 255, 0.5);
        --card-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.1);

        /* ç»„ä»¶å˜é‡ */
        --btn-primary-bg: linear-gradient(135deg, var(--primary-color) 0%, var(--primary-light) 100%);
        --btn-danger-bg: linear-gradient(135deg, var(--danger-color) 0%, var(--danger-hover) 100%);
        --btn-hover-transform: translateY(-1px);
        --btn-hover-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);

        --btn-sec-bg: rgba(255, 255, 255, 0.5);
        --btn-sec-border: 1px solid rgba(255, 255, 255, 0.8);
        --btn-sec-color: var(--text-main);
        --btn-sec-hover-bg: rgba(255, 255, 255, 0.8);

        --top-btn-bg: var(--card-bg);
        --top-btn-color: var(--text-main);
        --top-btn-border: var(--card-border);
        
        --input-bg: rgba(255, 255, 255, 0.7);
        --input-border: 1px solid rgba(255, 255, 255, 0.6);
        --input-focus-bg: #fff;
        --input-focus-border: var(--primary-color);
        --input-focus-shadow: 0 0 0 3px rgba(102, 126, 234, 0.2);

        --item-bg: rgba(255, 255, 255, 0.5);
        --item-hover-bg: rgba(255, 255, 255, 0.8);
        --item-border-base: transparent;
        --item-hover-border: transparent;
        --item-hover-transform: translateX(2px);

        --divider-dashed: 1px dashed rgba(255, 255, 255, 0.3);
        --divider-solid: 1px solid rgba(0, 0, 0, 0.05);

        --msg-self-bg: linear-gradient(135deg, var(--primary-color), var(--primary-light));
        --msg-self-color: white;
        --msg-other-bg: rgba(255, 255, 255, 0.8);
        --msg-other-border: none;
        
        --timer-status-bg: rgba(255, 255, 255, 0.8);
        --stat-box-bg: rgba(255, 255, 255, 0.4);
        
        --video-box-bg: #000;
        --video-border: 2px solid transparent;
        --video-hover-border: var(--primary-light);
      }

      /* ================= 2. æç®€ä¸»é¢˜ï¼šç™½ç°æ‰å¹³ (Minimalist) ================= */
      [data-theme="minimal"] {
        --radius-sm: 6px;
        --radius-md: 10px;
        --radius-lg: 20px;

        --primary-color: #5c6ac4;
        --primary-light: #818cf8;
        --primary-hover: #4338ca;
        --danger-color: #ef4444;
        --danger-hover: #dc2626;
        --warning-color: #f59e0b;
        --text-main: #1f2937;
        --text-secondary: #4b5563;
        --text-tertiary: #9ca3af;

        --body-bg: #f4f5f7;
        --card-bg: #ffffff;
        --card-backdrop: none;
        --card-border: 1px solid #eaeaea;
        --card-shadow: 0 2px 8px rgba(0,0,0,0.03);

        --btn-primary-bg: var(--primary-color);
        --btn-danger-bg: var(--danger-color);
        --btn-hover-transform: none;
        --btn-hover-shadow: none;

        --btn-sec-bg: #ffffff;
        --btn-sec-border: 1px solid #eaeaea;
        --btn-sec-color: var(--text-secondary);
        --btn-sec-hover-bg: #f9fafc;

        --top-btn-bg: #ffffff;
        --top-btn-color: var(--text-secondary);
        --top-btn-border: 1px solid #eaeaea;

        --input-bg: #f9fafc;
        --input-border: 1px solid #eaeaea;
        --input-focus-bg: #fff;
        --input-focus-border: var(--primary-light);
        --input-focus-shadow: none;

        --item-bg: #f9fafc;
        --item-hover-bg: #f9fafc;
        --item-border-base: 1px solid transparent;
        --item-hover-border: 1px solid #eaeaea;
        --item-hover-transform: none;

        --divider-dashed: 1px solid #eaeaea;
        --divider-solid: 1px solid #eaeaea;

        --msg-self-bg: var(--primary-color);
        --msg-self-color: white;
        --msg-other-bg: #f9fafc;
        --msg-other-border: 1px solid #eaeaea;

        --timer-status-bg: #f9fafc;
        --stat-box-bg: #f9fafc;
        
        --video-box-bg: #000;
        --video-border: 1px solid #374151;
        --video-hover-border: 1px solid var(--text-tertiary);
      }

      * { box-sizing: border-box; margin: 0; padding: 0; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; }

      body {
        background: var(--body-bg);
        color: var(--text-main);
        height: 100vh; overflow: hidden; line-height: 1.5;
        transition: background 0.3s ease;
      }

      .glass-card {
        background: var(--card-bg);
        backdrop-filter: var(--card-backdrop);
        -webkit-backdrop-filter: var(--card-backdrop);
        border: var(--card-border);
        border-radius: var(--radius-md);
        box-shadow: var(--card-shadow);
        display: flex; flex-direction: column; overflow: hidden; padding: 20px;
        transition: all 0.3s ease;
      }

      .app-layout {
        display: grid; grid-template-columns: 320px 1fr 340px; grid-template-rows: 1fr 280px;
        gap: 20px; padding: 70px 20px 20px 20px; height: 100vh; width: 100vw;
      }

      #taskCard { grid-column: 1; grid-row: 1; overflow-y: auto; }
      #timerSettingsCard { grid-column: 1; grid-row: 2; height: max-content; }
      #videoCard { 
        grid-column: 2; grid-row: 1; position: relative; padding: 15px; 
        background: rgba(0, 0, 0, 0.4); border-color: transparent; 
      }
      /* åœ¨æç®€æ¨¡å¼ä¸‹åŠ æ·±ä¸€ç‚¹èƒŒæ™¯å‡¸æ˜¾è§†é¢‘åŒº */
      [data-theme="minimal"] #videoCard { background: #111827; }

      #timerDisplayCard { grid-column: 2; grid-row: 2; display: flex; flex-direction: row; gap: 20px; padding: 25px; }
      #chatCard { grid-column: 3; grid-row: 1 / span 2; display: flex; flex-direction: column; overflow: hidden; }
      #taskCard, #timerSettingsCard { transform: translateY(-33px); transition: transform 0.2s ease; z-index: 5; }

      .top-center-controls { position: absolute; top: 20px; left: 50%; transform: translateX(-50%); display: flex; gap: 15px; z-index: 20; }
      .top-center-controls button {
        padding: 10px 16px; border-radius: var(--radius-lg); border: var(--top-btn-border);
        cursor: pointer; background: var(--top-btn-bg); color: var(--top-btn-color);
        font-weight: 500; font-size: 13px; box-shadow: var(--card-shadow); 
        backdrop-filter: var(--card-backdrop); transition: 0.3s;
      }
      .top-center-controls button:hover { background: #fff; color: var(--text-main); transform: translateY(-2px); }
      .top-center-controls button.active { background: var(--primary-color); color: #fff; border-color: var(--primary-color); }
      .top-center-controls button.btn-danger.active { background: var(--danger-color); color: #fff; border-color: var(--danger-color); }

      .top-bar { position: absolute; top: 20px; right: 20px; z-index: 20; display: flex; gap: 12px; }
      .stat-badge {
        background: var(--top-btn-bg); backdrop-filter: var(--card-backdrop); color: var(--text-main);
        padding: 8px 16px; border-radius: var(--radius-lg); font-size: 13px; font-weight: 500;
        border: var(--top-btn-border); display: flex; align-items: center; gap: 8px; box-shadow: var(--card-shadow);
      }
      .host-badge { background: var(--warning-color); color: #fff; padding: 2px 8px; border-radius: var(--radius-sm); font-size: 11px; font-weight: 600; margin-left: 6px; }

      .video-grid { display: flex; gap: 15px; width: 100%; height: 100%; justify-content: center; align-items: stretch; }
      .video-box {
        background: var(--video-box-bg); border-radius: var(--radius-sm); overflow: hidden; position: relative; cursor: pointer;
        border: var(--video-border); transition: all 0.3s ease; display: flex; flex-direction: column; box-shadow: var(--shadow-md);
      }
      .video-box:hover { border: var(--video-hover-border); transform: translateY(-2px); }
      .video-box video { width: 100%; height: 100%; object-fit: contain; flex: 1; }
      .video-box.no-video { display: none !important; }

      .video-label {
        position: absolute; bottom: 10px; left: 10px; right: 10px; background: rgba(0, 0, 0, 0.6);
        color: white; padding: 8px 12px; border-radius: var(--radius-sm); font-size: 13px; display: flex;
        justify-content: space-between; align-items: flex-end; backdrop-filter: blur(4px);
      }
      .video-info-text { display: flex; flex-direction: column; gap: 4px; }
      .vol-slider { width: 60px; accent-color: var(--primary-color); cursor: pointer; }
      .video-box.large, .video-box.default-main { flex: 1; min-width: 0; height: 100%; }
      .video-sidebar { width: 25%; max-width: 280px; min-width: 160px; display: flex; flex-direction: column; gap: 10px; overflow-y: auto; padding-right: 5px; }
      .video-sidebar .video-box { width: 100%; height: auto; aspect-ratio: 16/9; flex-shrink: 0; }
      .video-sidebar.empty { display: none; }

      .panel-header h3 { font-size: 16px; font-weight: 600; margin-bottom: 15px; color: var(--text-main); display: flex; align-items: center; gap: 8px; }
      .input-group { display: flex; gap: 10px; margin-bottom: 15px; }
      input[type="text"], input[type="number"] {
        flex: 1; padding: 10px 14px; border: var(--input-border); border-radius: var(--radius-sm);
        background: var(--input-bg); outline: none; transition: 0.2s; color: var(--text-main);
      }
      input:focus { background: var(--input-focus-bg); border-color: var(--input-focus-border); box-shadow: var(--input-focus-shadow); }

      button.styled-btn {
        padding: 10px 18px; border-radius: var(--radius-sm); border: none; cursor: pointer;
        background: var(--btn-primary-bg); color: white; font-weight: 500; transition: 0.2s;
      }
      button.styled-btn:hover { box-shadow: var(--btn-hover-shadow); transform: var(--btn-hover-transform); opacity: 0.9; }
      button.styled-btn.secondary { background: var(--btn-sec-bg); color: var(--btn-sec-color); border: var(--btn-sec-border); }
      button.styled-btn.secondary:hover { background: var(--btn-sec-hover-bg); }
      button.styled-btn.danger { background: var(--btn-danger-bg); }

      #listsContainer { flex: 1; overflow-y: auto; }
      .task-item {
        display: flex; align-items: center; justify-content: space-between; padding: 10px;
        background: var(--item-bg); border-radius: var(--radius-sm); margin-bottom: 8px;
        transition: 0.2s; border: var(--item-border-base); font-size: 14px;
      }
      .task-item:hover { background: var(--item-hover-bg); transform: var(--item-hover-transform); border: var(--item-hover-border); }
      .task-item.completed span { text-decoration: line-through; color: var(--text-secondary); opacity: 0.6; }

      .timer-main-area { flex: 0.9; display: flex; flex-direction: column; align-items: center; justify-content: center; border-right: var(--divider-dashed); padding-right: 20px; }
      .timer-stats-area { flex: 1.1; display: flex; flex-direction: column; gap: 15px; overflow: hidden; padding-left: 10px; }

      .timer-display { font-size: 72px; font-weight: bold; color: var(--text-main); font-family: -apple-system, BlinkMacSystemFont, sans-serif; line-height: 1; margin: 15px 0; letter-spacing: 2px; }
      .timer-status-bar { padding: 6px 16px; border-radius: var(--radius-lg); background: var(--timer-status-bg); font-weight: 500; font-size: 13px; color: var(--text-secondary); border: var(--divider-solid); }

      .stats-overview { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
      .stat-box { background: var(--stat-box-bg); padding: 12px 15px; border-radius: var(--radius-sm); display: flex; flex-direction: column; gap: 5px; border: var(--item-border-base); }
      .stat-label { font-size: 12px; color: var(--text-secondary); }
      .stat-val { font-size: 24px; font-weight: bold; color: var(--text-main); line-height: 1; }

      .focus-timeline-container { flex: 1; overflow-y: auto; padding-left: 8px; margin-top: 5px; }
      .timeline-item { position: relative; padding-left: 20px; padding-bottom: 20px; border-left: 2px solid var(--primary-light); }
      .timeline-item:last-child { border-left-color: transparent; }
      .timeline-item::before {
        content: ""; position: absolute; left: -6px; top: 0; width: 10px; height: 10px;
        border-radius: 50%; background: var(--primary-color); border: 2px solid #fff; box-shadow: 0 0 0 1px var(--primary-light);
      }
      [data-theme="minimal"] .timeline-item { padding-left: 16px; border-left: 1px solid var(--border-color); }
      [data-theme="minimal"] .timeline-item::before { left: -4px; top: 4px; width: 7px; height: 7px; border: none; box-shadow: none; }
      .timeline-time { font-size: 12px; color: var(--text-tertiary); display: flex; justify-content: space-between; margin-bottom: 4px; }
      .timeline-task { font-size: 14px; font-weight: 500; color: var(--text-main); }

      .timer-settings { display: flex; flex-direction: column; gap: 12px; }
      .audio-upload { margin-top: 10px; padding-top: 10px; border-top: var(--divider-dashed); }
      .audio-upload input[type="file"] { font-size: 12px; width: 100%; margin-top: 5px; color: var(--text-secondary); }

      .user-list { display: flex; flex-direction: column; gap: 8px; overflow-y: auto; max-height: 0; opacity: 0; margin-bottom: 0; padding-bottom: 0; border-bottom: 0px solid transparent; transition: all 0.4s ease; }
      .user-list.show { max-height: 40%; opacity: 1; margin-bottom: 10px; padding-bottom: 10px; border-bottom: var(--divider-dashed); }
      .user-list-item { background: var(--item-bg); padding: 8px 12px; border-radius: var(--radius-sm); display: flex; flex-direction: column; gap: 4px; border: var(--input-border); transition: 0.2s; flex-shrink: 0; }
      .user-list-item:hover { background: var(--item-hover-bg); }
      .user-list-name { font-size: 13px; font-weight: 600; color: var(--text-main); }
      .user-list-status { font-size: 11px; color: var(--text-secondary); }

      .chat-messages { flex: 1; overflow-y: auto; padding: 10px 5px; display: flex; flex-direction: column; gap: 12px; }
      .message {
        font-size: 13px; padding: 12px; border-radius: 12px 12px 12px 0;
        background: var(--msg-other-bg); border: var(--msg-other-border); color: var(--msg-other-color);
        align-self: flex-start; max-width: 85%; word-wrap: break-word; user-select: none;
      }
      .message.self { align-self: flex-end; background: var(--msg-self-bg); color: var(--msg-self-color); border-radius: 12px 12px 0 12px; border: none; }
      .message .msg-meta { font-size: 11px; color: var(--text-tertiary); margin-bottom: 4px; }
      .message.self .msg-meta { color: rgba(255, 255, 255, 0.7); text-align: right; }
      .message img { max-width: 100%; border-radius: 8px; margin-top: 8px; cursor: pointer; }
      .nudge-msg { text-align: center; font-size: 12px; color: #888; margin: 4px 0; background: none; box-shadow: none; border: none; align-self: center; padding: 0; }

      ::-webkit-scrollbar { width: 6px; }
      ::-webkit-scrollbar-track { background: transparent; }
      ::-webkit-scrollbar-thumb { background: rgba(0, 0, 0, 0.15); border-radius: 10px; }
      ::-webkit-scrollbar-thumb:hover { background: rgba(0, 0, 0, 0.3); }
      [data-theme="minimal"] ::-webkit-scrollbar-thumb { background: #d1d5db; }
      [data-theme="minimal"] ::-webkit-scrollbar-thumb:hover { background: #9ca3af; }
    </style>
  </head>
  <body>
    <div class="top-center-controls">
      <button id="btnMic" onclick="toggleMic()">ğŸ¤ éº¦å…‹é£</button>
      <button id="btnCam" onclick="toggleCam()">ğŸ“· æ‘„åƒå¤´</button>
      <button id="btnScreen" onclick="toggleScreenShare()" class="btn-danger">ğŸ’» å±å¹•</button>
      <button onclick="toggleTheme()" title="åˆ‡æ¢ä¸»é¢˜æ ·å¼">ğŸŒ— åˆ‡æ¢ä¸»é¢˜</button>
      <button class="styled-btn secondary" onclick="window.location.href = '/index.html'">ğŸšª è¿”å›</button>
    </div>

    <div class="top-bar">
      <div class="stat-badge"><span id="myNameDisplay">åŠ è½½ä¸­...</span></div>
      <div class="stat-badge" id="hostStatusBadge" style="display: none; background: var(--warning-color); color: #fff; border: none">ğŸ‘‘ æˆ¿ä¸»</div>
      <div class="stat-badge" onclick="toggleUserList()" style="cursor: pointer; user-select: none" title="ç‚¹å‡»å±•å¼€/æ”¶èµ·æˆå‘˜åˆ—è¡¨">ğŸ‘¥ åœ¨çº¿: <span id="userCountDisplay">1</span></div>
    </div>

    <div class="app-layout">
      <div class="glass-card" id="taskCard">
        <div class="panel-header"><h3>ğŸ“‹ ä»»åŠ¡æ¸…å•</h3></div>
        <div class="input-group">
          <input type="text" id="newListInput" placeholder="è¾“å…¥æ¸…å•åç§°..." />
          <button class="styled-btn" onclick="createList()">æ–°å»º</button>
        </div>
        <div id="listsContainer"></div>
      </div>

      <div class="glass-card" id="timerSettingsCard">
        <div class="panel-header" style="margin-bottom: 10px"><h3>âš™ï¸ è®¡æ—¶è®¾ç½®</h3></div>
        <div class="timer-settings">
          <div style="display: flex; justify-content: space-between; align-items: center;">
            <span style="font-size: 13px; font-weight: 500">ä¸“æ³¨(åˆ†): <input type="number" id="focusTime" value="40" style="width: 60px; padding: 5px; text-align: center" /></span>
            <span style="font-size: 13px; font-weight: 500">ä¼‘æ¯(åˆ†): <input type="number" id="breakTime" value="5" style="width: 60px; padding: 5px; text-align: center" /></span>
          </div>
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-top: 5px;">
            <button class="styled-btn" onclick="startPomodoro()">ç•ªèŒ„é’Ÿ</button>
            <button class="styled-btn secondary" onclick="startStopwatch()">æ­£è®¡æ—¶</button>
            <button class="styled-btn" id="btnPause" onclick="togglePauseTimer()" style="display: none; background: var(--warning-color); color: #000">æš‚åœ</button>
            <button class="styled-btn danger" onclick="stopTimer()">ç»“æŸ</button>
          </div>
          <div class="audio-upload">
            <label style="font-size: 11px; font-weight: 500; color: var(--text-secondary);">ğŸµ è‡ªå®šä¹‰éŸ³æ•ˆ (MP3, &lt;10MB)</label>
            <input type="file" id="alarmSound" accept=".mp3,audio/mpeg" onchange="handleAudioUpload(event)" />
          </div>
        </div>
      </div>

      <div class="glass-card" id="videoCard">
        <div class="video-grid" id="videoGrid">
          <div class="video-box default-main no-video" id="localVideoBox" onclick="togglePin('localVideoBox')">
            <video id="localVideo" autoplay muted playsinline></video>
            <div class="video-label">
              <div class="video-info-text">
                <div style="font-weight: 600; font-size: 13px; margin-bottom: 2px">æˆ‘</div>
                <div style="font-size: 11px; color: #e2e8f0" id="localVideoStatus">æœªå¼€å¯</div>
              </div>
            </div>
          </div>
        </div>
      </div>

      <div class="glass-card" id="timerDisplayCard">
        <div class="timer-main-area">
          <div id="currentTaskDisplay" style="font-size: 14px; font-weight: 500; color: var(--text-secondary);">ä¸“æ³¨ï¼šæš‚æ— ä»»åŠ¡</div>
          <div class="timer-display" id="timeDisplay">40:00</div>
          <div class="timer-status-bar" id="timerStatus">å‡†å¤‡å°±ç»ª</div>
        </div>

        <div class="timer-stats-area">
          <div class="stats-overview">
            <div class="stat-box">
              <div class="stat-label">ä»Šæ—¥ç•ªèŒ„</div>
              <div class="stat-val" id="statPomodoros">0</div>
            </div>
            <div class="stat-box">
              <div class="stat-label">ä»Šæ—¥æ—¶é•¿</div>
              <div class="stat-val" id="statFocusTime">0 m</div>
            </div>
          </div>

          <div style="font-weight: 500; font-size: 14px; margin-top: 5px; color: var(--text-main);">ä¸“æ³¨è®°å½•</div>
          <div class="focus-timeline-container" id="timelineContainer"></div>
        </div>
      </div>

      <div class="glass-card" id="chatCard">
        <div class="panel-header">
          <h3>ğŸ’¬ äº’åŠ¨åŒº</h3>
          <button id="hostChatToggleBtn" class="styled-btn danger" style="display: none; padding: 4px 8px; font-size: 11px" onclick="toggleRoomChat()">ç¦è¨€å…¨å‘˜</button>
        </div>
        <div class="user-list" id="userListContainer"></div>
        <div class="chat-messages" id="chatBox"></div>

        <div class="input-group" style="margin-bottom: 0; margin-top: 10px">
          <input type="file" id="imageInput" accept="image/png, image/jpeg, image/gif" style="display: none" onchange="handleImageUpload(event)" />
          <button class="styled-btn secondary" onclick="document.getElementById('imageInput').click()" title="å‘é€å›¾ç‰‡">ğŸ–¼ï¸</button>
          <input type="text" id="reflectionInput" placeholder="å‘é€æ¶ˆæ¯..." />
          <button class="styled-btn" id="btnSendChat" onclick="sendReflection()">å‘é€</button>
        </div>
      </div>
    </div>

    <script>
    // ================= ä¸»é¢˜åˆ‡æ¢é€»è¾‘ =================
    function toggleTheme() {
        const currentTheme = document.documentElement.getAttribute('data-theme');
        const newTheme = currentTheme === 'minimal' ? 'glass' : 'minimal';
        
        if (newTheme === 'minimal') {
            document.documentElement.setAttribute('data-theme', 'minimal');
        } else {
            document.documentElement.removeAttribute('data-theme');
        }
        localStorage.setItem('study_theme', newTheme);
        renderTasks(); // é‡æ–°æ¸²æŸ“åˆ—è¡¨ä»¥åº”ç”¨è¾¹æ¡†çº¿æ ·å¼
    }

    // ================= åŸæ ¸å¿ƒåŠŸèƒ½åŒº =================
    const urlParams = new URLSearchParams(window.location.search);
    const ROOM_ID = urlParams.get('room') || 'default_study_room';
    
    let socket;
    let myUserId;
    let isHost = false;
    let roomUsers = [];
    let roomDataFromServer = { names: {}, timers: {} };
    let myNickname = localStorage.getItem('study_nickname') || 'åŒå­¦';
    let currentMainId = 'localVideoBox';
    let isLargeMode = false;
    let currentFocusTask = ''; 

    let totalPomodoros = 0;
    let totalFocusMinutes = 0;
    let sessionAccumulatedSecs = 0;
    let recordTaskName = '';
    let isCurrentPomodoro = false;

    let isUserListVisible = false;
    function toggleUserList() {
        isUserListVisible = !isUserListVisible;
        const container = document.getElementById('userListContainer');
        isUserListVisible ? container.classList.add('show') : container.classList.remove('show');
    }

    let peerConnections = {}; 
    let localStream = null;      
    let cameraTrack = null; 
    let micAudioTrack = null;
    let screenVideoTrack = null; 
    let screenAudioTrack = null; 
    let isCamOpen = false;
    let isMicOpen = false;
    let isSharingScreen = false; 

    let nudgeCooldowns = {};

    let alarmAudio = new Audio();
    function handleAudioUpload(event) {
        const file = event.target.files[0];
        if (!file) return;
        if (file.size > 10 * 1024 * 1024) { alert('æ–‡ä»¶è¿‡å¤§ï¼'); event.target.value = ''; return; }
        alarmAudio.src = URL.createObjectURL(file);
        alert('è‡ªå®šä¹‰éŸ³æ•ˆè®¾ç½®æˆåŠŸï¼');
    }

    function playAlarmSound() {
        if (alarmAudio.src) { alarmAudio.play().catch(e => {}); } 
        else {
            try {
                const ctx = new (window.AudioContext || window.webkitAudioContext)();
                const osc = ctx.createOscillator(); const gain = ctx.createGain();
                osc.connect(gain); gain.connect(ctx.destination);
                osc.type = 'sine'; osc.frequency.setValueAtTime(600, ctx.currentTime);
                gain.gain.setValueAtTime(0, ctx.currentTime); gain.gain.linearRampToValueAtTime(0.5, ctx.currentTime + 0.1);
                gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 1.5);
                osc.start(); osc.stop(ctx.currentTime + 1.5);
            } catch(e) {}
        }
    }

    document.body.addEventListener('click', () => { document.querySelectorAll('audio, video').forEach(m => { if (m.paused && m.srcObject) m.play().catch(e => {}); }); }, { once: true });

    window.onload = () => { 
        document.title = `è‡ªä¹ å®¤: ${ROOM_ID}`;
        initSocket(); 
        renderTasks(); 
        arrangeLayout(currentMainId, isLargeMode); 
        restoreStateOnLoad(); 
    };

    function initSocket() {
        const token = localStorage.getItem('study_token');
        if (!token) return window.location.href = '/index.html';

        socket = io({ auth: { token: token } });
        socket.on('connect_error', (err) => {
            if (err.message.includes('æˆæƒ') || err.message.includes('Token')) {
                localStorage.removeItem('study_token'); window.location.href = '/index.html';
            }
        });

        socket.on('connect', () => {
            myUserId = socket.id;
            document.getElementById('myNameDisplay').innerText = myNickname;
            socket.emit('join_room', ROOM_ID);
        });

        socket.on('room_update', (data) => {
            roomDataFromServer = data; 
            roomUsers = data.users;
            document.getElementById('userCountDisplay').innerText = roomUsers.length;
            isHost = (data.host === myUserId);
            document.getElementById('hostStatusBadge').style.display = isHost ? 'flex' : 'none';
            document.getElementById('hostChatToggleBtn').style.display = isHost ? 'block' : 'none';
            
            renderUserList(data.host);
            updateAllVideoLabels();
            broadcastMediaStatus(); 
            
            const chatInput = document.getElementById('reflectionInput');
            const chatBtn = document.getElementById('btnSendChat');
            if (!data.chatEnabled && !isHost) {
                chatInput.disabled = true; chatBtn.disabled = true; chatInput.placeholder = "å…¨å‘˜ç¦è¨€ä¸­";
            } else {
                chatInput.disabled = false; chatBtn.disabled = false; chatInput.placeholder = "å‘é€æ¶ˆæ¯...";
            }
        });

        socket.on('chat_message', (msgData) => {
            if (msgData.isSystem && msgData.action === 'media_status') return handleMediaStatusUpdate(msgData.userId, msgData.hasVideo);
            if (msgData.isNudge) appendNudgeMessage(msgData.message);
            else appendMessage(msgData.userName, msgData.message, msgData.time, false, msgData.isImage);
        });

        socket.on('user_joined', async (newUserId) => {
            createPeerConnection(newUserId);
            if (localStream) localStream.getTracks().forEach(track => { if (peerConnections[newUserId]) peerConnections[newUserId].addTrack(track, localStream); });
            broadcastMediaStatus();
        });

        socket.on('offer', async (data) => {
            const pc = createPeerConnection(data.caller);
            await pc.setRemoteDescription(new RTCSessionDescription(data.sdp));
            if (localStream) localStream.getTracks().forEach(track => { if (!pc.getSenders().some(s => s.track === track)) pc.addTrack(track, localStream); });
            const answer = await pc.createAnswer(); await pc.setLocalDescription(answer);
            socket.emit('answer', { target: data.caller, serval: myUserId, sdp: answer });
            broadcastMediaStatus();
        });

        socket.on('answer', async (data) => { if (peerConnections[data.serval]) await peerConnections[data.serval].setRemoteDescription(new RTCSessionDescription(data.sdp)); });
        socket.on('ice-candidate', async (data) => { if (peerConnections[data.from]) await peerConnections[data.from].addIceCandidate(new RTCIceCandidate(data.candidate)); });
        socket.on('user_left', (userId) => { closePeerConnection(userId); });
    }

    function renderUserList(hostId) {
        const container = document.getElementById('userListContainer'); container.innerHTML = '';
        const sortedUsers = [...roomUsers].sort((a, b) => { if (a === myUserId) return -1; if (b === myUserId) return 1; return 0; });
        sortedUsers.forEach(id => {
            const item = document.createElement('div'); item.className = 'user-list-item';
            if (id === myUserId) item.style.borderLeft = '4px solid var(--primary-color)';
            item.innerHTML = `<div class="user-list-name" id="list_name_${id}">åŠ è½½ä¸­...</div><div class="user-list-status" id="list_status_${id}">åŠ è½½ä¸­...</div>`;
            container.appendChild(item);
        });
        updateAllVideoLabels();
    }

    function updateAllVideoLabels() {
        roomUsers.forEach(id => {
            const isMe = (id === myUserId);
            const customName = isMe ? myNickname : (roomDataFromServer.names[id] || `æˆå‘˜(${id.substring(0,4)})`);
            const isPomodoro = document.getElementById('timerStatus').innerText.includes('ä¸“æ³¨');
            const timerStatus = isMe ? getTimerStatusString(isPomodoro) : (roomDataFromServer.timers[id] || 'æš‚æ— ä»»åŠ¡');
            
            const labelContainer = isMe ? document.querySelector('#localVideoBox .video-info-text') : document.querySelector(`#box_${id} .video-info-text`);
            if (labelContainer) labelContainer.innerHTML = `<div style="font-weight:600; font-size:13px; margin-bottom:2px;">${customName}</div><div style="font-size:11px; opacity:0.8;">${timerStatus}</div>`;

            const listItemName = document.getElementById(`list_name_${id}`); const listItemStatus = document.getElementById(`list_status_${id}`);
            if (listItemName && listItemStatus) {
                listItemName.innerHTML = `${isMe ? `${customName} (æˆ‘)` : customName}${id === roomDataFromServer.host ? ' ğŸ‘‘' : ''}`;
                listItemStatus.innerHTML = timerStatus;
            }
        });
    }

    const rtcConfig = { iceServers: [{ urls: 'stun:stun.l.google.com:19302' }, { urls: 'stun:stun1.l.google.com:19302' }], iceCandidatePoolSize: 10 };

    function adjustRemoteVolume(remoteUserId, value) { document.querySelectorAll(`.user-audio-${remoteUserId}`).forEach(el => el.volume = parseFloat(value)); }

    function createPeerConnection(remoteUserId) {
        if (peerConnections[remoteUserId]) return peerConnections[remoteUserId];
        const pc = new RTCPeerConnection(rtcConfig); peerConnections[remoteUserId] = pc;
        let isNegotiating = false;
        pc.onsignalingstatechange = () => { isNegotiating = (pc.signalingState !== "stable"); };
        pc.onicecandidate = (event) => { if (event.candidate) socket.emit('ice-candidate', { target: remoteUserId, from: myUserId, candidate: event.candidate }); };
        pc.onnegotiationneeded = async () => {
            if (isNegotiating) return;
            isNegotiating = true;
            try {
                const offer = await pc.createOffer(); await pc.setLocalDescription(offer);
                socket.emit('offer', { target: remoteUserId, caller: myUserId, sdp: pc.localDescription });
            } catch (e) {} finally { isNegotiating = false; }
        };

        pc.ontrack = (event) => {
            if (event.track.kind === 'audio') {
                const audioId = `audio_${event.track.id}`; let audioEl = document.getElementById(audioId);
                if (!audioEl) {
                    audioEl = document.createElement('audio'); audioEl.id = audioId; audioEl.autoplay = true; 
                    audioEl.className = `user-audio-${remoteUserId}`; audioEl.srcObject = new MediaStream([event.track]);
                    document.body.appendChild(audioEl); event.track.onended = () => { if (audioEl) audioEl.remove(); };
                }
            }
            if (event.track.kind === 'video') {
                let remoteVideoE = document.getElementById(`video_${remoteUserId}`);
                if (!remoteVideoE) {
                    const html = `<div class="video-box no-video" id="box_${remoteUserId}" onclick="togglePin('box_${remoteUserId}')">
                        <video id="video_${remoteUserId}" autoplay playsinline muted></video>
                        <div class="video-label">
                            <div class="video-info-text"><div style="font-weight:600; font-size:13px; margin-bottom:2px;">åŠ è½½ä¸­...</div><div style="font-size:11px; opacity:0.8;"></div></div>
                            <input type="range" class="vol-slider" min="0" max="1" step="0.05" value="1" onclick="event.stopPropagation();" oninput="adjustRemoteVolume('${remoteUserId}', this.value)" title="è°ƒèŠ‚éŸ³é‡">
                        </div></div>`;
                    document.getElementById('videoGrid').insertAdjacentHTML('beforeend', html);
                    remoteVideoE = document.getElementById(`video_${remoteUserId}`);
                }
                if (remoteVideoE.srcObject !== event.streams[0]) remoteVideoE.srcObject = event.streams[0];
                updateAllVideoLabels(); setTimeout(() => arrangeLayout(currentMainId, isLargeMode), 50);
            }
        };
        return pc;
    }

    function closePeerConnection(userId) {
        if (peerConnections[userId]) { peerConnections[userId].close(); delete peerConnections[userId]; }
        const box = document.getElementById(`box_${userId}`); if (box) box.remove();
        document.querySelectorAll(`.user-audio-${userId}`).forEach(el => el.remove());
        if (currentMainId === `box_${userId}`) { currentMainId = 'localVideoBox'; isLargeMode = false; }
        setTimeout(() => arrangeLayout(currentMainId, isLargeMode), 50);
    }

    function syncTracksToPeers() {
        if (!localStream) localStream = new MediaStream();
        localStream.getTracks().forEach(t => localStream.removeTrack(t));
        if (isCamOpen && cameraTrack) localStream.addTrack(cameraTrack);
        if (isSharingScreen && screenVideoTrack) localStream.addTrack(screenVideoTrack);
        if (isMicOpen && micAudioTrack) localStream.addTrack(micAudioTrack);
        if (isSharingScreen && screenAudioTrack) localStream.addTrack(screenAudioTrack);

        Object.values(peerConnections).forEach(pc => {
            const senders = pc.getSenders();
            senders.forEach(sender => { if (sender.track && !localStream.getTracks().includes(sender.track)) pc.removeTrack(sender); });
            localStream.getTracks().forEach(track => { if (!senders.some(s => s.track === track)) pc.addTrack(track, localStream); });
        });
        broadcastMediaStatus();
    }

    function broadcastMediaStatus() {
        const hasV = isCamOpen || isSharingScreen;
        if(socket) socket.emit('chat_message', { isSystem: true, action: 'media_status', userId: myUserId, hasVideo: hasV });
        handleMediaStatusUpdate(myUserId, hasV);
    }

    function handleMediaStatusUpdate(userId, hasVideo) {
        const boxId = userId === myUserId ? 'localVideoBox' : `box_${userId}`; const box = document.getElementById(boxId);
        if (box) {
            if (hasVideo) box.classList.remove('no-video');
            else { box.classList.add('no-video'); if (currentMainId === boxId) { currentMainId = 'localVideoBox'; isLargeMode = false; } }
            arrangeLayout(currentMainId, isLargeMode);
        }
    }

    function updateLocalVideoSrc() {
        const localVideo = document.getElementById('localVideo');
        if (isSharingScreen && screenVideoTrack) localVideo.srcObject = new MediaStream([screenVideoTrack]);
        else if (isCamOpen && cameraTrack) localVideo.srcObject = new MediaStream([cameraTrack]);
        else localVideo.srcObject = null;
    }

    async function toggleCam() {
        const btn = document.getElementById('btnCam');
        if (!isCamOpen) {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ video: true }); cameraTrack = stream.getVideoTracks()[0];
                cameraTrack.onended = () => { if(isCamOpen) toggleCam(); }; isCamOpen = true; btn.innerText = "ğŸ“· å…³é—­"; btn.classList.add('active');
            } catch (err) { return alert("æ— æ³•è®¿é—®æ‘„åƒå¤´: " + err.message); }
        } else {
            if (cameraTrack) { cameraTrack.stop(); cameraTrack = null; }
            isCamOpen = false; btn.innerText = "ğŸ“· æ‘„åƒå¤´"; btn.classList.remove('active');
        }
        updateLocalVideoSrc(); syncTracksToPeers();
    }

    async function toggleMic() {
        const btn = document.getElementById('btnMic');
        if (!isMicOpen) {
            try { 
                if (!micAudioTrack) { const stream = await navigator.mediaDevices.getUserMedia({ audio: true }); micAudioTrack = stream.getAudioTracks()[0]; micAudioTrack.onended = () => { if(isMicOpen) toggleMic(); }; }
                micAudioTrack.enabled = true; isMicOpen = true; btn.innerText = "ğŸ¤ å…³é—­"; btn.classList.add('active'); 
            } catch(e) { return alert("æ— æ³•è·å–éº¦å…‹é£æƒé™ï¼"); }
        } else { 
            if (micAudioTrack) { micAudioTrack.enabled = false; micAudioTrack.stop(); micAudioTrack = null; }
            isMicOpen = false; btn.innerText = "ğŸ¤ éº¦å…‹é£"; btn.classList.remove('active'); 
        }
        syncTracksToPeers();
    }

    async function toggleScreenShare() {
        const btn = document.getElementById('btnScreen');
        if (!isSharingScreen) {
            if (isCamOpen) await toggleCam(); 
            try {
                const stream = await navigator.mediaDevices.getDisplayMedia({ video: true, audio: true });
                screenVideoTrack = stream.getVideoTracks()[0]; screenAudioTrack = stream.getAudioTracks()[0]; 
                screenVideoTrack.onended = () => { if(isSharingScreen) toggleScreenShare(); };
                isSharingScreen = true; btn.innerText = "ğŸ’» åœæ­¢"; btn.classList.add('active');
            } catch (err) { return; } 
        } else {
            if (screenVideoTrack) { screenVideoTrack.stop(); screenVideoTrack = null; }
            if (screenAudioTrack) { screenAudioTrack.stop(); screenAudioTrack = null; }
            isSharingScreen = false; btn.innerText = "ğŸ’» å±å¹•"; btn.classList.remove('active'); 
        }
        updateLocalVideoSrc(); syncTracksToPeers();
    }

    function togglePin(boxId) {
        if (currentMainId === boxId && isLargeMode) { isLargeMode = false; currentMainId = 'localVideoBox'; } 
        else { currentMainId = boxId; isLargeMode = true; }
        arrangeLayout(currentMainId, isLargeMode);
    }

    function arrangeLayout(mainId, large) {
        const grid = document.getElementById('videoGrid'); const allBoxes = Array.from(document.querySelectorAll('.video-box'));
        const activeBoxes = allBoxes.filter(b => !b.classList.contains('no-video'));
        allBoxes.forEach(b => { if (b.parentNode) b.parentNode.removeChild(b); });
        grid.innerHTML = '';
        if (activeBoxes.length === 0) {
            grid.innerHTML = '<div style="color:var(--text-tertiary); margin:auto; font-size:15px; font-weight: 500;">ç­‰å¾…æˆå‘˜å¼€å¯ç”»é¢...</div>';
            allBoxes.filter(b => b.classList.contains('no-video')).forEach(b => { b.style.display = 'none'; grid.appendChild(b); }); return;
        }
        let mainBox = activeBoxes.find(b => b.id === mainId) || activeBoxes.find(b => b.id === 'localVideoBox') || activeBoxes[0];
        activeBoxes.forEach(b => { b.style.display = 'flex'; b.classList.remove('large', 'default-main'); });
        large ? mainBox.classList.add('large') : mainBox.classList.add('default-main'); grid.appendChild(mainBox);
        const others = activeBoxes.filter(b => b.id !== mainBox.id);
        if (others.length > 0) {
            const sidebar = document.createElement('div'); sidebar.className = 'video-sidebar';
            others.forEach(b => sidebar.appendChild(b)); grid.appendChild(sidebar);
        }
        allBoxes.filter(b => b.classList.contains('no-video')).forEach(b => { b.style.display = 'none'; grid.appendChild(b); });
    }

    let timerInterval; let totalSeconds = 0; let isTimerRunning = false; let isTimerPaused = false; 

    function getTimerStatusString(isPomodoro) {
        if (!isTimerRunning && !isTimerPaused) return currentFocusTask ? `å¾…ä¸“æ³¨ï¼š${currentFocusTask}` : 'æœªå¼€å§‹';
        const m = Math.floor(totalSeconds / 60); const s = (totalSeconds % 60).toString().padStart(2, '0');
        const timeStr = isPomodoro ? `å‰©ä½™ ${m}:${s}` : `å·²è®¡ ${m}:${s}`;
        const taskName = currentFocusTask || (isPomodoro ? "ç•ªèŒ„é’Ÿ" : "æ­£è®¡æ—¶");
        return `${taskName} | ${timeStr}${isTimerPaused ? " (æš‚åœ)" : ""}`;
    }

    function broadcastTimerStatus(isPomodoro) { if (socket) socket.emit('sync_timer', getTimerStatusString(isPomodoro)); }

    function updateDisplay(sec) {
        document.getElementById('timeDisplay').innerText = `${Math.floor(sec / 60).toString().padStart(2, '0')}:${(sec % 60).toString().padStart(2, '0')}`;
        const isPomodoro = document.getElementById('timerStatus').innerText.includes('ä¸“æ³¨') || isCurrentPomodoro;
        const localLabelSpan = document.getElementById('localVideoStatus');
        if(localLabelSpan) localLabelSpan.innerText = getTimerStatusString(isPomodoro);
        if (sec % 5 === 0) broadcastTimerStatus(isPomodoro);
    }

    function updateStatsUI() {
        document.getElementById('statPomodoros').innerText = totalPomodoros;
        let h = Math.floor(totalFocusMinutes / 60); let m = totalFocusMinutes % 60;
        document.getElementById('statFocusTime').innerText = h > 0 ? `${h}h ${m}m` : `${m}m`;
    }

    function saveTimerStateToLocal() {
        if (!isTimerRunning && totalSeconds === 0 && sessionAccumulatedSecs === 0) return;
        const state = { type: isCurrentPomodoro ? 'pomodoro' : 'stopwatch', savedSeconds: totalSeconds, accumulatedSecs: sessionAccumulatedSecs, task: currentFocusTask };
        localStorage.setItem('study_timer_state', JSON.stringify(state));
    }

    function clearTimerState() { localStorage.removeItem('study_timer_state'); }

    async function restoreStateOnLoad() {
        const token = localStorage.getItem('study_token');
        try {
            const res = await fetch('/api/records/today', { headers: { 'Authorization': `Bearer ${token}` } });
            if (res.ok) {
                const data = await res.json();
                totalPomodoros = data.pomodoros; totalFocusMinutes = data.totalMins; updateStatsUI();
                document.getElementById('timelineContainer').innerHTML = '';
                data.history.forEach(item => { if(item.task) appendFocusRecordStr(item.time, item.task, item.mins); });
            }
        } catch (e) { }

        const savedStateStr = localStorage.getItem('study_timer_state');
        if (savedStateStr) {
            const state = JSON.parse(savedStateStr);
            if (state.savedSeconds > 0 || state.accumulatedSecs > 0) {
                totalSeconds = state.savedSeconds; sessionAccumulatedSecs = state.accumulatedSecs || 0; 
                setFocusTask(state.task); 
                
                isTimerRunning = true; isTimerPaused = true; 
                isCurrentPomodoro = (state.type === 'pomodoro');
                recordTaskName = currentFocusTask || (isCurrentPomodoro ? "ç•ªèŒ„é’Ÿ" : "æ­£è®¡æ—¶");

                const btnPause = document.getElementById('btnPause');
                btnPause.style.display = 'inline-block'; btnPause.innerText = 'ç»§ç»­'; 
                document.getElementById('timerStatus').innerText = "â¸ï¸ å·²æš‚åœ";
                
                updateDisplay(totalSeconds);

                timerInterval = setInterval(() => {
                    if (!isTimerPaused) {
                        sessionAccumulatedSecs++; 
                        if (isCurrentPomodoro) {
                            if (totalSeconds > 0) {
                                totalSeconds--; updateDisplay(totalSeconds); saveTimerStateToLocal();
                            } else {
                                clearInterval(timerInterval); recordFocusSession(true); playAlarmSound(); clearTimerState(); 
                                alert("ä¸“æ³¨ç»“æŸï¼å¼€å§‹ä¼‘æ¯å§ã€‚"); stopTimer(true); 
                            }
                        } else {
                            totalSeconds++; updateDisplay(totalSeconds); saveTimerStateToLocal();
                        }
                    }
                }, 1000);
            }
        }
    }

    function setFocusTask(taskName) {
        currentFocusTask = taskName;
        const statusEl = document.getElementById('timerStatus');
        const taskDisplayEl = document.getElementById('currentTaskDisplay');
        taskDisplayEl.innerText = taskName ? `ğŸ¯ ä¸“æ³¨ï¼š${taskName}` : 'ä¸“æ³¨ï¼šæš‚æ— ä»»åŠ¡';
        
        const isPomodoro = statusEl.innerText.includes('ä¸“æ³¨') || statusEl.innerText.includes('æš‚åœ') || isCurrentPomodoro;
        if (isTimerRunning || isTimerPaused) broadcastTimerStatus(isPomodoro);
        else { statusEl.innerText = `å‡†å¤‡å°±ç»ª`; broadcastTimerStatus(false); }

        const localLabelSpan = document.getElementById('localVideoStatus');
        if(localLabelSpan) localLabelSpan.innerText = getTimerStatusString(isPomodoro);
        if (isTimerRunning) saveTimerStateToLocal();
    }

    async function recordFocusSession(isFinishedPomodoro = false) {
        const mins = Math.floor(sessionAccumulatedSecs / 60); 
        if (mins >= 1) {
            totalFocusMinutes += mins;
            if (isCurrentPomodoro && isFinishedPomodoro) totalPomodoros++;
            updateStatsUI();
            
            const now = new Date();
            const start = new Date(now.getTime() - sessionAccumulatedSecs * 1000);
            const timeStr = `${start.toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'})} - ${now.toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'})}`;
            appendFocusRecordStr(timeStr, recordTaskName, mins);
            
            const token = localStorage.getItem('study_token');
            if (token) {
                fetch('/api/records', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${token}` },
                    body: JSON.stringify({ task_name: recordTaskName, duration_mins: mins })
                });
            }
        }
        sessionAccumulatedSecs = 0; saveTimerStateToLocal();
    }

    function appendFocusRecordStr(timeStr, taskName, durationMins) {
        const html = `<div class="timeline-item"><div class="timeline-time"><span>${timeStr}</span><span style="font-weight:600; color:var(--primary-color);">${durationMins}m</span></div><div class="timeline-task">${taskName}</div></div>`;
        document.getElementById('timelineContainer').insertAdjacentHTML('afterbegin', html);
    }

    function startStopwatch() {
        clearInterval(timerInterval);
        totalSeconds = 0; sessionAccumulatedSecs = 0; isTimerRunning = true; isTimerPaused = false;
        recordTaskName = currentFocusTask || "æ­£è®¡æ—¶"; isCurrentPomodoro = false;
        document.getElementById('timerStatus').innerText = "â³ æ­£è®¡æ—¶ä¸­";
        document.getElementById('btnPause').style.display = 'inline-block'; document.getElementById('btnPause').innerText = 'æš‚åœ';
        broadcastTimerStatus(false); saveTimerStateToLocal();

        timerInterval = setInterval(() => { 
            if (!isTimerPaused) { totalSeconds++; sessionAccumulatedSecs++; updateDisplay(totalSeconds); saveTimerStateToLocal(); } 
        }, 1000);
    }

    function startPomodoro() {
        clearInterval(timerInterval);
        const mins = parseInt(document.getElementById('focusTime').value) || 25;
        totalSeconds = mins * 60; sessionAccumulatedSecs = 0; isTimerRunning = true; isTimerPaused = false;
        recordTaskName = currentFocusTask || "ç•ªèŒ„é’Ÿ"; isCurrentPomodoro = true;
        document.getElementById('timerStatus').innerText = "ğŸ”¥ ä¸“æ³¨ä¸­";
        document.getElementById('btnPause').style.display = 'inline-block'; document.getElementById('btnPause').innerText = 'æš‚åœ';
        updateDisplay(totalSeconds); broadcastTimerStatus(true); saveTimerStateToLocal();
        
        timerInterval = setInterval(() => {
            if (!isTimerPaused) {
                sessionAccumulatedSecs++;
                if (totalSeconds > 0) { totalSeconds--; updateDisplay(totalSeconds); saveTimerStateToLocal(); } 
                else {
                    clearInterval(timerInterval); recordFocusSession(true); playAlarmSound(); clearTimerState(); 
                    alert("ä¸“æ³¨ç»“æŸï¼å¼€å§‹ä¼‘æ¯å§ã€‚"); stopTimer(true); 
                }
            }
        }, 1000);
    }

    function togglePauseTimer() {
        if (!isTimerRunning) return;
        isTimerPaused = !isTimerPaused;
        const btn = document.getElementById('btnPause'); const status = document.getElementById('timerStatus');
        if (isTimerPaused) { btn.innerText = "ç»§ç»­"; status.innerText = "â¸ï¸ å·²æš‚åœ"; } 
        else { btn.innerText = "æš‚åœ"; status.innerText = isCurrentPomodoro ? "ğŸ”¥ ä¸“æ³¨ä¸­" : "â³ æ­£è®¡æ—¶ä¸­"; }
        
        const localLabelSpan = document.getElementById('localVideoStatus');
        if(localLabelSpan) localLabelSpan.innerText = getTimerStatusString(isCurrentPomodoro);
        broadcastTimerStatus(isCurrentPomodoro); saveTimerStateToLocal();
    }

    function stopTimer(skipRecord = false) {
        clearInterval(timerInterval);
        if (!skipRecord) recordFocusSession(false); 
        clearTimerState(); isTimerRunning = false; isTimerPaused = false; sessionAccumulatedSecs = 0;
        document.getElementById('timerStatus').innerText = "å‡†å¤‡å°±ç»ª";
        document.getElementById('btnPause').style.display = 'none';
        const localLabelSpan = document.getElementById('localVideoStatus');
        if(localLabelSpan) localLabelSpan.innerText = getTimerStatusString(false);
        broadcastTimerStatus(false);
    }

    let tasksState = JSON.parse(localStorage.getItem('study_tasks_data')) || [{ id: 'default', name: 'ä»Šæ—¥ç›®æ ‡', tasks: [] }];

    function saveTasksData() { localStorage.setItem('study_tasks_data', JSON.stringify(tasksState)); }

    function renderTasks() {
        const container = document.getElementById('listsContainer');
        container.innerHTML = '';
        tasksState.forEach(list => {
            const listHtml = `<div style="margin-bottom:15px; border-bottom:var(--divider-dashed); padding-bottom:10px;">
                <div style="font-weight:600; margin-bottom:10px; font-size:15px; color:var(--text-main); display:flex; justify-content:space-between;">
                    <span>ğŸ“‚ ${list.name}</span>
                    <button class="styled-btn danger" style="padding:2px 6px; font-size:12px; opacity:0.8;" onclick="deleteList('${list.id}')">åˆ </button>
                </div>
                <div style="display:flex; gap:8px;">
                    <input type="text" id="taskInput_${list.id}" placeholder="è¾“å…¥ä»»åŠ¡å†…å®¹..." onkeypress="if(event.key==='Enter') addTask('${list.id}')">
                    <button class="styled-btn" style="padding: 6px 12px;" onclick="addTask('${list.id}')">+</button>
                </div>
                <div id="tasks_${list.id}" style="margin-top:12px;">
                    ${list.tasks.map(t => `
                        <div class="task-item ${t.completed ? 'completed' : ''}" id="${t.id}">
                            <label style="flex:1; display:flex; align-items:center; gap:8px; cursor:pointer;">
                                <input type="checkbox" ${t.completed ? 'checked' : ''} onclick="toggleTask('${list.id}', '${t.id}')"> 
                                <span style="font-weight:500;">${t.name}</span>
                            </label>
                            <button class="styled-btn" style="padding: 4px 10px; font-size: 12px; border-radius: 4px;" onclick="setFocusTask('${t.name}')">é€‰å®š</button>
                            <button class="styled-btn danger" style="padding: 4px 8px; font-size: 12px; border-radius: 4px; margin-left: 4px;" onclick="deleteTask('${list.id}', '${t.id}')">âœ–</button>
                        </div>
                    `).join('')}
                </div></div>`;
            container.insertAdjacentHTML('beforeend', listHtml);
        });
    }

    function createList(presetName) {
        let name = typeof presetName === 'string' ? presetName : '';
        if (!name) {
            const inputEl = document.getElementById('newListInput');
            if (inputEl) { name = inputEl.value.trim(); inputEl.value = ''; }
        }
        if (!name) name = 'æ–°æ¸…å•';
        tasksState.push({ id: `list_${Date.now()}`, name: name, tasks: [] });
        saveTasksData(); renderTasks();
    }

    function deleteList(listId) {
        if(confirm('ç¡®å®šåˆ é™¤æ•´ä¸ªæ¸…å•å—ï¼Ÿ')) { tasksState = tasksState.filter(l => l.id !== listId); saveTasksData(); renderTasks(); }
    }
    
    function addTask(listId) {
        const val = document.getElementById(`taskInput_${listId}`).value.trim();
        if(!val) return;
        const list = tasksState.find(l => l.id === listId);
        if (list) { list.tasks.push({ id: `task_${Date.now()}`, name: val, completed: false }); saveTasksData(); renderTasks(); }
    }

    function toggleTask(listId, taskId) {
        const list = tasksState.find(l => l.id === listId);
        if (list) {
            const task = list.tasks.find(t => t.id === taskId);
            if (task) { task.completed = !task.completed; saveTasksData(); renderTasks(); }
        }
    }

    function deleteTask(listId, taskId) {
        const list = tasksState.find(l => l.id === listId);
        if (list) { list.tasks = list.tasks.filter(t => t.id !== taskId); saveTasksData(); renderTasks(); }
    }

    function handleImageUpload(event) {
        const file = event.target.files[0]; if (!file) return; const reader = new FileReader();
        reader.onload = (e) => {
            const b64 = e.target.result; const t = new Date().toLocaleTimeString(); appendMessage(myNickname, b64, t, true, true);
            if(socket) socket.emit('chat_message', { userName: isHost ? `ğŸ‘‘æˆ¿ä¸»(${myNickname})` : myNickname, message: b64, time: t, isImage: true });
        }; reader.readAsDataURL(file); event.target.value = ''; 
    }

    function sendReflection() {
        const input = document.getElementById('reflectionInput'); const msg = input.value.trim(); if (!msg) return;
        const t = new Date().toLocaleTimeString(); appendMessage(myNickname, msg, t, true, false);
        if(socket) socket.emit('chat_message', { userName: isHost ? `ğŸ‘‘æˆ¿ä¸»(${myNickname})` : myNickname, message: msg, time: t, isImage: false });
        input.value = '';
    }

    function handleNudge(targetUser) {
        const now = Date.now(); if (nudgeCooldowns[targetUser] && now - nudgeCooldowns[targetUser] < 3000) return;
        nudgeCooldowns[targetUser] = now; const msg = `${myNickname} æ‹äº†æ‹ ${targetUser}`; appendNudgeMessage(msg); 
        if(socket) socket.emit('chat_message', { userName: myNickname, message: msg, time: new Date().toLocaleTimeString(), isNudge: true });
    }

    function appendNudgeMessage(msgText) { const box = document.getElementById('chatBox'); box.insertAdjacentHTML('beforeend', `<div class="message nudge-msg">${msgText}</div>`); box.scrollTop = box.scrollHeight; }

    function appendMessage(user, msg, time, isSelf, isImage = false) {
        const box = document.getElementById('chatBox');
        const contentHtml = isImage ? `<img src="${msg}" onclick="window.open(this.src)">` : `<div>${msg}</div>`;
        const safeUser = user.replace(/'/g, "\\'"); 
        box.insertAdjacentHTML('beforeend', `<div class="message ${isSelf ? 'self' : ''}" ondblclick="handleNudge('${safeUser}')" title="åŒå‡»æ‹ä¸€æ‹"><div class="msg-meta">${user} ${time}</div>${contentHtml}</div>`);
        box.scrollTop = box.scrollHeight;
    }
    </script>
  </body>
</html>